/**
 * API Test Service
 * 测试 Claude API 配置的连接性和性能
 *
 * Features:
 * - 单个配置测试
 * - 批量分组测试
 * - 延迟测量
 * - 结果记录
 */

use crate::db::DbPool;
use crate::models::error::{AppError, AppResult};
use crate::models::test_result::{TestResult, TestStatus};
use crate::services::api_config::ApiConfigService;
use crate::services::keychain::KeychainManager;
use chrono::Utc;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tauri::{AppHandle, Manager};
use tokio::sync::RwLock;
use tokio::time::timeout;

/// API 测试超时时间(秒)
const TEST_TIMEOUT_SECS: u64 = 5;

/// API 测试服务
pub struct ApiTestService {
    db_pool: Arc<DbPool>,
    app_handle: Arc<RwLock<Option<AppHandle>>>,
}

impl ApiTestService {
    /// 创建新的 API 测试服务
    pub fn new(db_pool: Arc<DbPool>) -> Self {
        Self {
            db_pool,
            app_handle: Arc::new(RwLock::new(None)),
        }
    }

    /// 设置 Tauri app handle 用于事件推送
    pub async fn set_app_handle(&self, handle: AppHandle) {
        let mut app_handle = self.app_handle.write().await;
        *app_handle = Some(handle);
        log::debug!("Tauri app handle set for API test service");
    }

    /// 推送 test-completed 事件
    async fn emit_test_completed(&self, result: &TestResult) {
        let app_handle = self.app_handle.read().await;
        if let Some(handle) = app_handle.as_ref() {
            if let Err(e) = handle.emit("test-completed", result) {
                log::error!("Failed to emit test-completed event: {}", e);
            } else {
                log::debug!("Emitted test-completed event for config {}", result.config_id);
            }
        }
    }

    /// 测试单个 API 配置
    ///
    /// # Arguments
    /// - `config_id`: API 配置 ID
    ///
    /// # Returns
    /// - TestResult: 测试结果(包含延迟、状态等信息)
    pub async fn test_single_config(&self, config_id: i64) -> AppResult<TestResult> {
        log::info!("Testing API config: {}", config_id);

        // 获取配置信息
        let config = self.db_pool.with_connection(|conn| {
            ApiConfigService::get_config_by_id(conn, config_id)
        })?;

        // 获取 API 密钥
        let api_key = match KeychainManager::get_api_key(config_id) {
            Ok(key) => key,
            Err(e) => {
                log::error!("Failed to get API key for config {}: {}", config_id, e);
                return Ok(self.create_failed_result(
                    config_id,
                    &format!("无法获取 API 密钥: {}", e),
                ));
            }
        };

        // 执行测试
        let start_time = Instant::now();
        let test_result = match timeout(
            Duration::from_secs(TEST_TIMEOUT_SECS),
            self.perform_api_test(&config.server_url, config.server_port, &api_key),
        )
        .await
        {
            Ok(Ok(())) => {
                let latency_ms = start_time.elapsed().as_millis() as i64;
                log::info!("Config {} test passed, latency: {}ms", config_id, latency_ms);
                self.create_success_result(config_id, latency_ms)
            }
            Ok(Err(e)) => {
                let latency_ms = start_time.elapsed().as_millis() as i64;
                log::warn!("Config {} test failed: {}", config_id, e);
                self.create_failed_result(config_id, &e)
            }
            Err(_) => {
                log::warn!("Config {} test timeout after {}s", config_id, TEST_TIMEOUT_SECS);
                self.create_timeout_result(config_id)
            }
        };

        // 更新配置的测试结果
        self.update_config_test_result(config_id, &test_result)?;

        // 保存测试结果到数据库
        self.save_test_result(&test_result)?;

        // 推送事件
        self.emit_test_completed(&test_result).await;

        Ok(test_result)
    }

    /// 测试分组内所有配置
    ///
    /// # Arguments
    /// - `group_id`: 分组 ID
    ///
    /// # Returns
    /// - Vec<TestResult>: 所有配置的测试结果
    pub async fn test_group_configs(&self, group_id: i64) -> AppResult<Vec<TestResult>> {
        log::info!("Testing all configs in group: {}", group_id);

        // 获取分组内所有配置
        let configs = self.db_pool.with_connection(|conn| {
            ApiConfigService::list_configs(conn, Some(group_id))
        })?;

        if configs.is_empty() {
            return Err(AppError::EmptyGroup { group_id });
        }

        // 并行测试所有配置
        let mut test_tasks = Vec::new();
        for config in configs {
            let service = ApiTestService::new(self.db_pool.clone());
            let task = tokio::spawn(async move {
                service.test_single_config(config.id).await
            });
            test_tasks.push(task);
        }

        // 收集测试结果
        let mut results = Vec::new();
        for task in test_tasks {
            match task.await {
                Ok(Ok(result)) => results.push(result),
                Ok(Err(e)) => {
                    log::error!("Test task failed: {}", e);
                }
                Err(e) => {
                    log::error!("Test task panicked: {}", e);
                }
            }
        }

        log::info!("Group {} test completed: {}/{} passed",
            group_id,
            results.iter().filter(|r| r.is_success).count(),
            results.len()
        );

        Ok(results)
    }

    /// 执行实际的 API 测试
    ///
    /// 发送一个简单的 HTTP 请求到 API 服务器
    async fn perform_api_test(
        &self,
        server_url: &str,
        server_port: i32,
        api_key: &str,
    ) -> Result<(), String> {
        use hyper::{Method, Request};
        use hyper::client::conn::http1;
        use hyper_util::rt::TokioIo;
        use http_body_util::Empty;
        use hyper::body::Bytes;
        use tokio::net::TcpStream;

        // 构建目标地址
        let target_addr = format!("{}:{}", server_url, server_port);

        // 连接到服务器
        let stream = TcpStream::connect(&target_addr)
            .await
            .map_err(|e| format!("连接失败: {}", e))?;

        let io = TokioIo::new(stream);

        // HTTP 握手
        let (mut sender, conn) = http1::handshake(io)
            .await
            .map_err(|e| format!("HTTP 握手失败: {}", e))?;

        // 在后台处理连接
        tokio::spawn(async move {
            if let Err(err) = conn.await {
                log::debug!("Connection error: {}", err);
            }
        });

        // 构建测试请求 (简单的 HEAD 请求或健康检查)
        let req = Request::builder()
            .method(Method::HEAD)
            .uri("/")
            .header("x-api-key", api_key)
            .header("user-agent", "claude-code-router/test")
            .body(Empty::<Bytes>::new())
            .map_err(|e| format!("构建请求失败: {}", e))?;

        // 发送请求
        let response = sender
            .send_request(req)
            .await
            .map_err(|e| format!("请求失败: {}", e))?;

        // 检查响应状态
        if response.status().is_success() || response.status().as_u16() == 404 {
            // 404 也算测试通过,因为服务器有响应
            Ok(())
        } else {
            Err(format!("API 返回错误状态: {}", response.status()))
        }
    }

    /// 创建成功的测试结果
    fn create_success_result(&self, config_id: i64, latency_ms: i64) -> TestResult {
        TestResult {
            id: 0, // 将由数据库生成
            config_id,
            group_id: None,
            test_at: Utc::now().to_rfc3339(),
            status: TestStatus::Success,
            latency_ms: Some(latency_ms as i32),
            error_message: None,
            is_valid_key: Some(true),
        }
    }

    /// 创建失败的测试结果
    fn create_failed_result(&self, config_id: i64, error_message: &str) -> TestResult {
        TestResult {
            id: 0,
            config_id,
            group_id: None,
            test_at: Utc::now().to_rfc3339(),
            status: TestStatus::Failed,
            latency_ms: None,
            error_message: Some(error_message.to_string()),
            is_valid_key: Some(false),
        }
    }

    /// 创建超时的测试结果
    fn create_timeout_result(&self, config_id: i64) -> TestResult {
        TestResult {
            id: 0,
            config_id,
            group_id: None,
            test_at: Utc::now().to_rfc3339(),
            status: TestStatus::Timeout,
            latency_ms: None,
            error_message: Some(format!("测试超时(>{}秒)", TEST_TIMEOUT_SECS)),
            is_valid_key: None,
        }
    }

    /// 更新配置的测试结果
    fn update_config_test_result(&self, config_id: i64, result: &TestResult) -> AppResult<()> {
        self.db_pool.with_connection(|conn| {
            use rusqlite::params;

            let now = chrono::Utc::now().to_rfc3339();
            let is_available = if result.is_success { 1 } else { 0 };

            conn.execute(
                "UPDATE ApiConfig SET last_test_at = ?1, last_latency_ms = ?2, is_available = ?3, updated_at = ?4 WHERE id = ?5",
                params![now, result.latency_ms, is_available, now, config_id],
            ).map_err(|e| AppError::DatabaseError {
                message: format!("更新配置测试结果失败: {}", e),
            })?;

            Ok(())
        })
    }

    /// 保存测试结果到数据库
    fn save_test_result(&self, result: &TestResult) -> AppResult<i64> {
        self.db_pool.with_connection(|conn| {
            use rusqlite::params;

            let test_time_str = chrono::DateTime::from_timestamp(result.test_time, 0)
                .unwrap()
                .to_rfc3339();

            conn.execute(
                "INSERT INTO TestResult (config_id, test_time, is_success, latency_ms, error_message)
                 VALUES (?1, ?2, ?3, ?4, ?5)",
                params![
                    result.config_id,
                    test_time_str,
                    if result.is_success { 1 } else { 0 },
                    result.latency_ms,
                    result.error_message,
                ],
            ).map_err(|e| AppError::DatabaseError {
                message: format!("保存测试结果失败: {}", e),
            })?;

            Ok(conn.last_insert_rowid())
        })
    }

    /// 获取配置的最近测试结果
    pub fn get_recent_test_results(&self, config_id: i64, limit: i32) -> AppResult<Vec<TestResult>> {
        self.db_pool.with_connection(|conn| {
            use rusqlite::params;

            let mut stmt = conn
                .prepare(
                    "SELECT id, config_id, test_time, is_success, latency_ms, error_message
                     FROM TestResult
                     WHERE config_id = ?1
                     ORDER BY test_time DESC
                     LIMIT ?2",
                )
                .map_err(|e| AppError::DatabaseError {
                    message: format!("准备查询测试结果失败: {}", e),
                })?;

            let results = stmt
                .query_map(params![config_id, limit], |row| {
                    let test_time_str: String = row.get(2)?;
                    let test_time = chrono::DateTime::parse_from_rfc3339(&test_time_str)
                        .unwrap()
                        .timestamp();

                    Ok(TestResult {
                        id: row.get(0)?,
                        config_id: row.get(1)?,
                        test_time,
                        is_success: row.get::<_, i32>(3)? == 1,
                        latency_ms: row.get(4)?,
                        error_message: row.get(5)?,
                    })
                })
                .map_err(|e| AppError::DatabaseError {
                    message: format!("查询测试结果失败: {}", e),
                })?
                .collect::<Result<Vec<_>, _>>()
                .map_err(|e| AppError::DatabaseError {
                    message: format!("解析测试结果失败: {}", e),
                })?;

            Ok(results)
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::db::initialize_database;

    #[tokio::test]
    async fn test_create_test_results() {
        let conn = initialize_database().expect("Failed to initialize database");
        let db_pool = Arc::new(DbPool::new(conn));
        let service = ApiTestService::new(db_pool);

        let success_result = service.create_success_result(1, 150);
        assert!(success_result.is_success);
        assert_eq!(success_result.latency_ms, Some(150));
        assert!(success_result.error_message.is_none());

        let failed_result = service.create_failed_result(1, "Connection refused");
        assert!(!failed_result.is_success);
        assert!(failed_result.latency_ms.is_none());
        assert!(failed_result.error_message.is_some());

        let timeout_result = service.create_timeout_result(1);
        assert!(!timeout_result.is_success);
        assert!(timeout_result.error_message.is_some());
    }
}
